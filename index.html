#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>
#include <mcp_can.h>
#include <SPI.h>

#define CAN_CS 8
#define SCK_PIN 48
#define MISO_PIN 47
#define MOSI_PIN 38

MCP_CAN CAN0(CAN_CS);

#define SERVICE_UUID "6e400001-b5a3-f393-e0a9-e50e24dcca9e"
#define RX_UUID      "6e400002-b5a3-f393-e0a9-e50e24dcca9e"
#define TX_UUID      "6e400003-b5a3-f393-e0a9-e50e24dcca9e"

BLECharacteristic *pTxChar;
bool deviceConnected = false;
int nodeId = 0x0A; 
int protocolType = 0; 
unsigned long lastHeartbeat = 0;
byte nmtState = 0x05; 
byte ledBuffer[15] = {0};
unsigned long bootTimer = 0;
SemaphoreHandle_t canMutex;

void sendKeyPacket(uint16_t state) {
    uint32_t cid = 0x180 + nodeId;
    // Haltech expects Byte 0 (bits 0-7) and Byte 1 (bits 8-15)
    byte d[8] = { (byte)(state & 0xFF), (byte)((state >> 8) & 0xFF), 0, 0, (byte)(millis() / 100), 0, 0, 0 };
    if (xSemaphoreTake(canMutex, pdMS_TO_TICKS(5))) {
        CAN0.sendMsgBuf(cid, 0, 8, d);
        xSemaphoreGive(canMutex);
    }
}

void updateLed(int btn, int colorBit, bool state) {
    if (btn < 0 || btn >= 15) return;
    if (state) ledBuffer[btn] |= (1 << colorBit);
    else ledBuffer[btn] &= ~(1 << colorBit);
}

class MyActionCallbacks: public BLECharacteristicCallbacks {
    void onWrite(BLECharacteristic *pChar) {
        std::string v = pChar->getValue();
        if (v.length() == 0) return;
        
        if (v[0] == 'S') {
            // Correctly parse the string starting after 'S'
            uint16_t mask = (uint16_t)strtoul(v.substr(1).c_str(), NULL, 10);
            Serial.print("Button Snapshot: "); Serial.println(mask, BIN);
            sendKeyPacket(mask);
        } else if (v[0] == 'C') {
            int m, p, s; uint32_t nid; char instStr[10];
            sscanf(v.c_str(), "C,%d,%x,%d,%[^,],%d", &m, &nid, &p, instStr, &s);
            protocolType = p;
            nodeId = (protocolType == 1) ? nid : (int)strtol(instStr, NULL, 16);
            bootTimer = millis();
            Serial.print("Config Updated. NodeID: "); Serial.println(nodeId, HEX);
        }
    }
};

class MyServerCallbacks: public BLEServerCallbacks {
    void onConnect(BLEServer* pS) { deviceConnected = true; Serial.println("Phone Connected"); }
    void onDisconnect(BLEServer* pS) { deviceConnected = false; sendKeyPacket(0); Serial.println("Phone Disconnected"); BLEDevice::startAdvertising(); }
};

void setup() {
    Serial.begin(115200);
    canMutex = xSemaphoreCreateMutex();
    BLEDevice::init("PTM-Keypad");
    BLEServer *pServer = BLEDevice::createServer();
    pServer->setCallbacks(new MyServerCallbacks());
    BLEService *pService = pServer->createService(SERVICE_UUID);
    pTxChar = pService->createCharacteristic(TX_UUID, BLECharacteristic::PROPERTY_NOTIFY);
    pTxChar->addDescriptor(new BLE2902());
    BLECharacteristic *pRxChar = pService->createCharacteristic(RX_UUID, BLECharacteristic::PROPERTY_WRITE);
    pRxChar->setCallbacks(new MyActionCallbacks());
    pService->start();
    BLEDevice::startAdvertising();
    SPI.begin(SCK_PIN, MISO_PIN, MOSI_PIN, CAN_CS);
    if (CAN0.begin(MCP_ANY, CAN_1000KBPS, MCP_8MHZ) == CAN_OK) { 
        CAN0.setMode(MCP_NORMAL); 
        Serial.println("CAN Init OK");
    }
}

void loop() {
    unsigned long elapsed = millis() - bootTimer;
    if (protocolType == 0) {
        if (elapsed < 200) nmtState = 0x00; else if (elapsed < 1000) nmtState = 0x7F; else nmtState = 0x05;
    } else { nmtState = 0x05; }

    if (millis() - lastHeartbeat > (protocolType == 0 ? 150 : 1000)) {
        byte msg[1] = {nmtState};
        if (xSemaphoreTake(canMutex, pdMS_TO_TICKS(5))) {
            CAN0.sendMsgBuf(0x700 + nodeId, 0, 1, msg);
            xSemaphoreGive(canMutex);
        }
        lastHeartbeat = millis();
    }

    long unsigned int rxId; unsigned char len = 0; unsigned char buf[8];
    if (xSemaphoreTake(canMutex, pdMS_TO_TICKS(2))) {
        if (CAN0.readMsgBuf(&rxId, &len, buf) == CAN_OK) {
            xSemaphoreGive(canMutex);
            if (rxId == (uint32_t)(0x600 + nodeId)) {
                if (protocolType == 0 && buf[0] == 0x22 && buf[2] == 0x62) {
                    byte ack[8] = {0x60, 0x00, 0x62, buf[3], 0, 0, 0, 0};
                    CAN0.sendMsgBuf(0x580 + nodeId, 0, 8, ack);
                    byte sub = buf[3]; byte d = buf[4];
                    
                    // Full mapping logic
                    if (sub == 0x01) { updateLed(0,0,d&1);updateLed(0,1,d&2);updateLed(0,2,d&4);updateLed(1,0,d&8);updateLed(1,1,d&16);updateLed(1,2,d&32);updateLed(2,0,d&64);updateLed(2,1,d&128); }
                    else if (sub == 0x02) { updateLed(2,2,d&1);updateLed(3,0,d&2);updateLed(3,1,d&4);updateLed(3,2,d&8);updateLed(4,0,d&16);updateLed(4,1,d&32);updateLed(4,2,d&64);updateLed(5,0,d&128); }
                    else if (sub == 0x03) { updateLed(5,1,d&1);updateLed(5,2,d&2);updateLed(6,0,d&4);updateLed(6,1,d&8);updateLed(6,2,d&16);updateLed(7,0,d&32);updateLed(7,1,d&64);updateLed(7,2,d&128); }
                    else if (sub == 0x04) { updateLed(8,0,d&1);updateLed(8,1,d&2);updateLed(8,2,d&4);updateLed(9,0,d&8);updateLed(9,1,d&16);updateLed(9,2,d&32);updateLed(10,0,d&64);updateLed(10,1,d&128); }
                    else if (sub == 0x05) { updateLed(10,2,d&1);updateLed(11,0,d&2);updateLed(11,1,d&4);updateLed(11,2,d&8);updateLed(12,0,d&16);updateLed(12,1,d&32);updateLed(12,2,d&64);updateLed(13,0,d&128); }
                    else if (sub == 0x06) { updateLed(13,1,d&1);updateLed(13,2,d&2);updateLed(14,0,d&4);updateLed(14,1,d&8);updateLed(14,2,d&16); }
                    
                    if (deviceConnected) { pTxChar->setValue(ledBuffer, 15); pTxChar->notify(); }
                }
            }
        } else { xSemaphoreGive(canMutex); }
    }
}
